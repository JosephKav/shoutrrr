// Code generated by "shoutrrr-gen --lang go"; DO NOT EDIT.
package smtp

import (
	"fmt"
	"net/url"

	"github.com/containrrr/shoutrrr/pkg/conf"
	"github.com/containrrr/shoutrrr/pkg/format"
	"github.com/containrrr/shoutrrr/pkg/types"
)

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Props                          (
// (___________________________________)

type Config struct {
	Auth        authOption       `key:"auth" `
	Encryption  encryptionOption `key:"encryption" `
	FromAddress string           `key:"fromaddress,from" `
	FromName    string           `key:"fromname" `
	Host        string           `url:"host" `
	Password    string           `url:"password" `
	Port        int64            `url:"port" `
	Subject     string           `key:"subject,title" `
	ToAddresses []string         `key:"toaddresses,to" `
	UseHTML     bool             `key:"usehtml" `
	UseStartTLS bool             `key:"usestarttls,starttls" `
	Username    string           `url:"user" `
}

type configProp int

const (
	propAuth        configProp = 0
	propEncryption  configProp = 1
	propFromAddress configProp = 2
	propFromName    configProp = 3
	propHost        configProp = 4
	propPassword    configProp = 5
	propPort        configProp = 6
	propSubject     configProp = 7
	propToAddresses configProp = 8
	propUseHTML     configProp = 9
	propUseStartTLS configProp = 10
	propUsername    configProp = 11
	propCount                  = 12
)

var propInfo = types.ConfigPropInfo{
	PropNames: []string{
		"Auth",
		"Encryption",
		"FromAddress",
		"FromName",
		"Host",
		"Password",
		"Port",
		"Subject",
		"ToAddresses",
		"UseHTML",
		"UseStartTLS",
		"Username",
	},

	// Note that propKeys may not align with propNames, as a property can have no or multiple keys
	Keys: []string{
		"auth",
		"encryption",
		"from",
		"fromaddress",
		"fromname",
		"starttls",
		"subject",
		"title",
		"to",
		"toaddresses",
		"usehtml",
		"usestarttls",
	},

	DefaultValues: []string{
		"Unknown",
		"Auto",
		"",
		"",
		"",
		"",
		"25",
		"Shoutrrr Notification",
		"",
		"No",
		"Yes",
		"",
	},

	PrimaryKeys: []int{
		0,
		1,
		3,
		4,
		-1,
		-1,
		-1,
		6,
		9,
		10,
		11,
		-1,
	},

	KeyPropIndexes: map[string]int{
		"auth":        0,
		"encryption":  1,
		"from":        2,
		"fromaddress": 2,
		"fromname":    3,
		"starttls":    10,
		"subject":     7,
		"title":       7,
		"to":          8,
		"toaddresses": 8,
		"usehtml":     9,
		"usestarttls": 10,
	},
}

func (_ *Config) PropInfo() *types.ConfigPropInfo {
	return &propInfo
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  GetURL                         (
// (___________________________________)

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User:     conf.UserInfoOrNil(url.UserPassword(config.Username, config.Password)),
		Host:     conf.FormatHost(config.Host, config.Port),
		Path:     "",
		RawQuery: conf.QueryValues(config).Encode(),
		Scheme:   Scheme,
	}
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  SetURL                         (
// (___________________________________)

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(configURL *url.URL) error {
	if lc, ok := (interface{})(config).(types.ConfigWithLegacyURLSupport); ok {
		configURL = lc.UpdateLegacyURL(configURL)
	}
	updates := make(map[int]string, propCount)
	if port := configURL.Port(); port != "" {
		updates[int(propPort)] = port
	}
	updates[int(propHost)] = configURL.Hostname()
	if pwd, found := configURL.User.Password(); found {
		updates[int(propPassword)] = pwd
	}
	updates[int(propUsername)] = configURL.User.Username()
	if configURL.Path != "" && configURL.Path != "/" {
		return fmt.Errorf("unexpected path in config URL: %v", configURL.Path)
	}

	for key, value := range configURL.Query() {

		if propIndex, found := propInfo.PropIndexFor(key); found {
			updates[propIndex] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}

	err := config.Update(updates)
	if err != nil {
		return err
	}

	if config.FromAddress == "" {
		return fmt.Errorf("fromAddress missing from config URL")
	}

	if config.Host == "" {
		return fmt.Errorf("host missing from config URL")
	}

	if len(config.ToAddresses) == 0 {
		return fmt.Errorf("toAddresses missing from config URL")
	}

	return nil
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Enums / Options                (
// (___________________________________)

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{
		"Auth":       AuthOptions.Formatter,
		"Encryption": EncryptionOptions.Formatter,
	}
}

/* == Auth Option ============================= */

type authOption int

type authOptionVals struct {
	None      authOption
	Plain     authOption
	CRAMMD5   authOption
	Unknown   authOption
	OAuth2    authOption
	Login     authOption
	Formatter types.EnumFormatter
}

var AuthOptions = &authOptionVals{
	None:    0,
	Plain:   1,
	CRAMMD5: 2,
	Unknown: 3,
	OAuth2:  4,
	Login:   5,
	Formatter: format.CreateEnumFormatter([]string{
		"None",
		"Plain",
		"CRAMMD5",
		"Unknown",
		"OAuth2",
		"Login",
	}),
}

func (ov *authOptionVals) Parse(v string) (authOption, error) {
	if val := ov.Formatter.Parse(v); val != format.EnumInvalid {
		return authOption(val), nil
	} else {
		return authOption(val), fmt.Errorf("invalid option %q for Auth", v)
	}
}

func (o authOption) String() string {
	return AuthOptions.Formatter.Print(int(o))
}

/* == Encryption Option ======================= */

type encryptionOption int

type encryptionOptionVals struct {
	None        encryptionOption
	ExplicitTLS encryptionOption
	ImplicitTLS encryptionOption
	Auto        encryptionOption
	Formatter   types.EnumFormatter
}

var EncryptionOptions = &encryptionOptionVals{
	None:        0,
	ExplicitTLS: 1,
	ImplicitTLS: 2,
	Auto:        3,
	Formatter: format.CreateEnumFormatter([]string{
		"None",
		"ExplicitTLS",
		"ImplicitTLS",
		"Auto",
	}),
}

func (ov *encryptionOptionVals) Parse(v string) (encryptionOption, error) {
	if val := ov.Formatter.Parse(v); val != format.EnumInvalid {
		return encryptionOption(val), nil
	} else {
		return encryptionOption(val), fmt.Errorf("invalid option %q for Encryption", v)
	}
}

func (o encryptionOption) String() string {
	return EncryptionOptions.Formatter.Print(int(o))
}

// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[int]string) error {
	var last_err error
	for index, value := range updates {
		switch configProp(index) {
		case propAuth:
			if val, err := AuthOptions.Parse(value); err != nil {
				last_err = err
			} else {
				config.Auth = val
			}
		case propEncryption:
			if val, err := EncryptionOptions.Parse(value); err != nil {
				last_err = err
			} else {
				config.Encryption = val
			}
		case propFromAddress:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.FromAddress = val
			}
		case propFromName:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.FromName = val
			}
		case propHost:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Host = val
			}
		case propPassword:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Password = val
			}
		case propPort:
			if val, err := conf.ParseNumberValue(value, 10); err != nil {
				last_err = err
			} else {
				config.Port = val
			}
		case propSubject:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Subject = val
			}
		case propToAddresses:
			if val, err := conf.ParseListValue(value, ","); err != nil {
				last_err = err
			} else {
				config.ToAddresses = val
			}
		case propUseHTML:
			if val, err := conf.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.UseHTML = val
			}
		case propUseStartTLS:
			if val, err := conf.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.UseStartTLS = val
			}
		case propUsername:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Username = val
			}
		default:
			return fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %v: %v", propInfo.PropNames[index], last_err)
		}
	}
	return nil
}

// Update updates the Config from a map of it's properties
func (config *Config) PropValue(prop int) string {
	switch configProp(prop) {
	case propAuth:
		return AuthOptions.Formatter.Print(int(config.Auth))
	case propEncryption:
		return EncryptionOptions.Formatter.Print(int(config.Encryption))
	case propFromAddress:
		return conf.FormatTextValue(config.FromAddress)
	case propFromName:
		return conf.FormatTextValue(config.FromName)
	case propHost:
		return conf.FormatTextValue(config.Host)
	case propPassword:
		return conf.FormatTextValue(config.Password)
	case propPort:
		return conf.FormatNumberValue(config.Port, 10)
	case propSubject:
		return conf.FormatTextValue(config.Subject)
	case propToAddresses:
		return conf.FormatListValue(config.ToAddresses, ",")
	case propUseHTML:
		return conf.FormatToggleValue(config.UseHTML)
	case propUseStartTLS:
		return conf.FormatToggleValue(config.UseStartTLS)
	case propUsername:
		return conf.FormatTextValue(config.Username)
	default:
		return ""
	}
}
